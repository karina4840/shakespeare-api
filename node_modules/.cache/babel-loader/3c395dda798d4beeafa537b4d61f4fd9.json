{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"field\", \"values\", \"type\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport deepEqual from \"deep-equal\";\n/**\n * Given a list of applied Filters, find FilterValues based on\n * \"fieldName\" and \"filterType\".\n *\n * @param {*} filters\n * @param {*} name\n * @param {*} filterType\n */\n\nexport function findFilterValues(filters, name, filterType) {\n  var filter = filters.find(function (f) {\n    return f.field === name && f.type === filterType;\n  });\n  if (!filter) return [];\n  return filter.values;\n}\n/**\n * Given a list of applied Filters, remove a single FilterValue based on\n * \"fieldName\" and \"filterType\".\n *\n * @param {Filter[]} filters\n * @param {String} fieldName\n * @param {FilterValue} value\n * @param {FilterType} filterType\n */\n\nexport function removeSingleFilterValue(filters, fieldName, value, filterType) {\n  return filters.reduce(function (acc, filter) {\n    var field = filter.field,\n        values = filter.values,\n        type = filter.type,\n        rest = _objectWithoutProperties(filter, _excluded);\n\n    if (field === fieldName && (!filterType || type === filterType)) {\n      var updatedFilterValues = values.filter(function (filterValue) {\n        return !doFilterValuesMatch(filterValue, value);\n      });\n\n      if (updatedFilterValues.length > 0) {\n        return acc.concat(_objectSpread({\n          field: field,\n          values: updatedFilterValues,\n          type: type\n        }, rest));\n      } else {\n        return acc;\n      }\n    }\n\n    return acc.concat(filter);\n  }, []);\n}\n/**\n * Given a Facet and a list of applied Filters, mark the Facet Values\n * for that Facet as \"selected\" based on \"fieldName\" and \"filterType\".\n *\n * @param {Facet} facet\n * @param {String} fieldName\n * @param {Filter[]} filters\n * @param {FilterType} filterType\n */\n\nexport function markSelectedFacetValuesFromFilters(facet, filters, fieldName, filterType) {\n  var facetValues = facet.data;\n  var filterValuesForField = findFilterValues(filters, fieldName, filterType) || [];\n  return _objectSpread(_objectSpread({}, facet), {}, {\n    data: facetValues.map(function (facetValue) {\n      return _objectSpread(_objectSpread({}, facetValue), {}, {\n        selected: filterValuesForField.some(function (filterValue) {\n          return doFilterValuesMatch(filterValue, facetValue.value);\n        })\n      });\n    })\n  });\n}\n/**\n * Useful for determining when filter values match. This could be used\n * when matching applied filters back to facet options, or for determining\n * whether or not a filter already exists in a list of applied filters.\n *\n * @param {FilterValue} filterValue1\n * @param {FilterValue} filterValue2\n */\n\nexport function doFilterValuesMatch(filterValue1, filterValue2) {\n  if (filterValue1 && filterValue1.name && filterValue2 && filterValue2.name && filterValue1.name === filterValue2.name) // If two filters have matching names, then they are the same filter, there\n    // is no need to do a more expensive deep equal comparison.\n    //\n    // This is also important because certain filters and facets will have\n    // differing values than their corresponding facet options. For instance,\n    // consider a time-based facet like \"Last 10 Minutes\". The value of the\n    // filter will be different depending on when it was selected, but the name\n    // will always match.\n    return true; // We use 'strict = true' to do a '===' of leaves, rather than '=='\n\n  return deepEqual(filterValue1, filterValue2, {\n    strict: true\n  });\n} // Mix unique filter type from one array into the other\n\nexport function mergeFilters(filters1, filters2) {\n  if (!filters2) return filters1;\n  return filters2.reduce(function (acc, next) {\n    if (acc.find(function (f) {\n      return f.type === next.type && f.field === next.field;\n    })) {\n      return acc;\n    }\n\n    return [].concat(_toConsumableArray(acc), [next]);\n  }, filters1);\n}","map":{"version":3,"mappings":"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","names":["deepEqual","findFilterValues","filters","name","filterType","filter","find","f","field","type","values","removeSingleFilterValue","fieldName","value","reduce","acc","rest","updatedFilterValues","doFilterValuesMatch","filterValue","length","concat","markSelectedFacetValuesFromFilters","facet","facetValues","data","filterValuesForField","map","facetValue","selected","some","filterValue1","filterValue2","strict","mergeFilters","filters1","filters2","next"],"sources":["/Users/karina/Main/Study/Web Dev/elasticsearch-test-api/node_modules/@elastic/search-ui/src/helpers.js"],"sourcesContent":["import deepEqual from \"deep-equal\";\n\n/**\n * Given a list of applied Filters, find FilterValues based on\n * \"fieldName\" and \"filterType\".\n *\n * @param {*} filters\n * @param {*} name\n * @param {*} filterType\n */\nexport function findFilterValues(filters, name, filterType) {\n  const filter = filters.find(f => f.field === name && f.type === filterType);\n  if (!filter) return [];\n  return filter.values;\n}\n\n/**\n * Given a list of applied Filters, remove a single FilterValue based on\n * \"fieldName\" and \"filterType\".\n *\n * @param {Filter[]} filters\n * @param {String} fieldName\n * @param {FilterValue} value\n * @param {FilterType} filterType\n */\nexport function removeSingleFilterValue(filters, fieldName, value, filterType) {\n  return filters.reduce((acc, filter) => {\n    const { field, values, type, ...rest } = filter;\n    if (field === fieldName && (!filterType || type === filterType)) {\n      const updatedFilterValues = values.filter(\n        filterValue => !doFilterValuesMatch(filterValue, value)\n      );\n      if (updatedFilterValues.length > 0) {\n        return acc.concat({\n          field,\n          values: updatedFilterValues,\n          type,\n          ...rest\n        });\n      } else {\n        return acc;\n      }\n    }\n    return acc.concat(filter);\n  }, []);\n}\n\n/**\n * Given a Facet and a list of applied Filters, mark the Facet Values\n * for that Facet as \"selected\" based on \"fieldName\" and \"filterType\".\n *\n * @param {Facet} facet\n * @param {String} fieldName\n * @param {Filter[]} filters\n * @param {FilterType} filterType\n */\nexport function markSelectedFacetValuesFromFilters(\n  facet,\n  filters,\n  fieldName,\n  filterType\n) {\n  const facetValues = facet.data;\n  const filterValuesForField =\n    findFilterValues(filters, fieldName, filterType) || [];\n  return {\n    ...facet,\n    data: facetValues.map(facetValue => {\n      return {\n        ...facetValue,\n        selected: filterValuesForField.some(filterValue => {\n          return doFilterValuesMatch(filterValue, facetValue.value);\n        })\n      };\n    })\n  };\n}\n\n/**\n * Useful for determining when filter values match. This could be used\n * when matching applied filters back to facet options, or for determining\n * whether or not a filter already exists in a list of applied filters.\n *\n * @param {FilterValue} filterValue1\n * @param {FilterValue} filterValue2\n */\nexport function doFilterValuesMatch(filterValue1, filterValue2) {\n  if (\n    filterValue1 &&\n    filterValue1.name &&\n    filterValue2 &&\n    filterValue2.name &&\n    filterValue1.name === filterValue2.name\n  )\n    // If two filters have matching names, then they are the same filter, there\n    // is no need to do a more expensive deep equal comparison.\n    //\n    // This is also important because certain filters and facets will have\n    // differing values than their corresponding facet options. For instance,\n    // consider a time-based facet like \"Last 10 Minutes\". The value of the\n    // filter will be different depending on when it was selected, but the name\n    // will always match.\n    return true;\n  // We use 'strict = true' to do a '===' of leaves, rather than '=='\n  return deepEqual(filterValue1, filterValue2, { strict: true });\n}\n\n// Mix unique filter type from one array into the other\nexport function mergeFilters(filters1, filters2) {\n  if (!filters2) return filters1;\n\n  return filters2.reduce((acc, next) => {\n    if (acc.find(f => f.type === next.type && f.field === next.field)) {\n      return acc;\n    }\n    return [...acc, next];\n  }, filters1);\n}\n"]},"metadata":{},"sourceType":"module"}