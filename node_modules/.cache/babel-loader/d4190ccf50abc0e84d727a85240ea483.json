{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { createBrowserHistory as createHistory } from \"history\";\nimport queryString from \"./queryString\";\n\nfunction isNumericString(num) {\n  return !isNaN(num);\n}\n\nfunction toSingleValue(val) {\n  return Array.isArray(val) ? val[val.length - 1] : val;\n}\n\nfunction toSingleValueInteger(num) {\n  return toInteger(toSingleValue(num));\n}\n\nfunction toInteger(num) {\n  if (!isNumericString(num)) return;\n  return parseInt(num, 10);\n}\n\nfunction parseFiltersFromQueryParams(queryParams) {\n  return queryParams.filters;\n}\n\nfunction parseCurrentFromQueryParams(queryParams) {\n  return toSingleValueInteger(queryParams.current);\n}\n\nfunction parseSearchTermFromQueryParams(queryParams) {\n  return toSingleValue(queryParams.q);\n}\n\nfunction parseOldSortFromQueryParams(queryParams) {\n  var sortField = toSingleValue(queryParams[\"sort-field\"]);\n  var sortDirection = toSingleValue(queryParams[\"sort-direction\"]);\n  if (sortField) return [sortField, sortDirection];\n  return [];\n}\n\nfunction parseSizeFromQueryParams(queryParams) {\n  return toSingleValueInteger(queryParams.size);\n}\n\nfunction parseSortFromQueryParams(queryParams) {\n  return queryParams[\"sort\"];\n}\n\nfunction paramsToState(queryParams) {\n  var state = {\n    current: parseCurrentFromQueryParams(queryParams),\n    filters: parseFiltersFromQueryParams(queryParams),\n    searchTerm: parseSearchTermFromQueryParams(queryParams),\n    resultsPerPage: parseSizeFromQueryParams(queryParams),\n    sortField: parseOldSortFromQueryParams(queryParams)[0],\n    sortDirection: parseOldSortFromQueryParams(queryParams)[1],\n    sortList: parseSortFromQueryParams(queryParams)\n  };\n  return Object.keys(state).reduce(function (acc, key) {\n    var value = state[key];\n    if (value) acc[key] = value;\n    return acc;\n  }, {});\n}\n\nfunction stateToParams(_ref) {\n  var searchTerm = _ref.searchTerm,\n      current = _ref.current,\n      filters = _ref.filters,\n      resultsPerPage = _ref.resultsPerPage,\n      sortDirection = _ref.sortDirection,\n      sortField = _ref.sortField,\n      sortList = _ref.sortList;\n  var params = {};\n  if (current > 1) params.current = current;\n  if (searchTerm) params.q = searchTerm;\n  if (resultsPerPage) params.size = resultsPerPage;\n\n  if (filters && filters.length > 0) {\n    params[\"filters\"] = filters;\n  }\n\n  if (sortList && sortList.length > 0) {\n    params[\"sort\"] = sortList;\n  } else if (sortField) {\n    params[\"sort-field\"] = sortField;\n    params[\"sort-direction\"] = sortDirection;\n  }\n\n  return params;\n}\n\nfunction stateToQueryString(state) {\n  return queryString.stringify(stateToParams(state));\n}\n/**\n * The URL Manager is responsible for synchronizing state between\n * SearchDriver and the URL. There are 3 main cases we handle when\n * synchronizing:\n *\n * 1. When the app loads, SearchDriver will need to\n * read the current state from the URL, in order to perform the search\n * expressed by the query string. `getStateFromURL` is used for this case.\n *\n * 2. When the URL changes as a result of `pushState` or `replaceState`,\n * SearchDriver will need to be notified and given the updated state, so that\n * it can re-run the current search. `onURLStateChange` is used for this case.\n *\n * 3. When state changes internally in the SearchDriver, as a result of an\n * Action, it will need to notify the URLManager of the change. `pushStateToURL`\n * is used for this case.\n */\n\n\nvar URLManager = /*#__PURE__*/function () {\n  function URLManager() {\n    _classCallCheck(this, URLManager);\n\n    this.history = createHistory();\n    this.lastPushSearchString = \"\";\n  }\n  /**\n   * Parse the current URL into application state\n   *\n   * @return {Object} - The parsed state object\n   */\n\n\n  _createClass(URLManager, [{\n    key: \"getStateFromURL\",\n    value: function getStateFromURL() {\n      return paramsToState(queryString.parse(this.history.location.search));\n    }\n    /**\n     * Push the current state of the application to the URL\n     *\n     * @param {Object} state - The entire current state from the SearchDriver\n     * @param {boolean} options\n     * @param {boolean} options.replaceUrl - When pushing state to the URL, use history 'replace'\n     * rather than 'push' to avoid adding a new history entry\n     */\n\n  }, {\n    key: \"pushStateToURL\",\n    value: function pushStateToURL(state) {\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref2$replaceUrl = _ref2.replaceUrl,\n          replaceUrl = _ref2$replaceUrl === void 0 ? false : _ref2$replaceUrl;\n\n      var searchString = stateToQueryString(state);\n      this.lastPushSearchString = searchString;\n      var navigationFunction = replaceUrl ? this.history.replace : this.history.push;\n      navigationFunction({\n        search: \"?\".concat(searchString)\n      });\n    }\n    /**\n     * Add an event handler to be executed whenever state is pushed to the URL\n     *\n     * @callback requestCallback\n     * @param {Object} state - Updated application state parsed from the new URL\n     *\n     * @param {requestCallback} callback\n     */\n\n  }, {\n    key: \"onURLStateChange\",\n    value: function onURLStateChange(callback) {\n      var _this = this;\n\n      this.unlisten = this.history.listen(function (location) {\n        // If this URL is updated as a result of a pushState request, we don't\n        // want to notify that the URL changed.\n        if (\"?\".concat(_this.lastPushSearchString) === location.search) return; // Once we've decided to return based on lastPushSearchString, reset\n        // it so that we don't break back / forward button.\n\n        _this.lastPushSearchString = \"\";\n        callback(paramsToState(queryString.parse(location.search)));\n      });\n    }\n  }, {\n    key: \"tearDown\",\n    value: function tearDown() {\n      this.unlisten();\n    }\n  }]);\n\n  return URLManager;\n}();\n\nexport { URLManager as default };","map":{"version":3,"mappings":"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","names":["createBrowserHistory","createHistory","queryString","isNumericString","num","isNaN","toSingleValue","val","Array","isArray","length","toSingleValueInteger","toInteger","parseInt","parseFiltersFromQueryParams","queryParams","filters","parseCurrentFromQueryParams","current","parseSearchTermFromQueryParams","q","parseOldSortFromQueryParams","sortField","sortDirection","parseSizeFromQueryParams","size","parseSortFromQueryParams","paramsToState","state","searchTerm","resultsPerPage","sortList","Object","keys","reduce","acc","key","value","stateToParams","params","stateToQueryString","stringify","URLManager","_classCallCheck","history","lastPushSearchString","parse","location","search","replaceUrl","searchString","navigationFunction","replace","push","callback","unlisten","listen","_this"],"sources":["/Users/karina/Main/Study/Web Dev/7. Complited Projects/elasticsearch-test-api/node_modules/@elastic/search-ui/src/URLManager.js"],"sourcesContent":["import { createBrowserHistory as createHistory } from \"history\";\nimport queryString from \"./queryString\";\n\nfunction isNumericString(num) {\n  return !isNaN(num);\n}\n\nfunction toSingleValue(val) {\n  return Array.isArray(val) ? val[val.length - 1] : val;\n}\n\nfunction toSingleValueInteger(num) {\n  return toInteger(toSingleValue(num));\n}\n\nfunction toInteger(num) {\n  if (!isNumericString(num)) return;\n  return parseInt(num, 10);\n}\n\nfunction parseFiltersFromQueryParams(queryParams) {\n  return queryParams.filters;\n}\n\nfunction parseCurrentFromQueryParams(queryParams) {\n  return toSingleValueInteger(queryParams.current);\n}\n\nfunction parseSearchTermFromQueryParams(queryParams) {\n  return toSingleValue(queryParams.q);\n}\n\nfunction parseOldSortFromQueryParams(queryParams) {\n  const sortField = toSingleValue(queryParams[\"sort-field\"]);\n  const sortDirection = toSingleValue(queryParams[\"sort-direction\"]);\n\n  if (sortField) return [sortField, sortDirection];\n  return [];\n}\n\nfunction parseSizeFromQueryParams(queryParams) {\n  return toSingleValueInteger(queryParams.size);\n}\n\nfunction parseSortFromQueryParams(queryParams) {\n  return queryParams[\"sort\"];\n}\n\nfunction paramsToState(queryParams) {\n  const state = {\n    current: parseCurrentFromQueryParams(queryParams),\n    filters: parseFiltersFromQueryParams(queryParams),\n    searchTerm: parseSearchTermFromQueryParams(queryParams),\n    resultsPerPage: parseSizeFromQueryParams(queryParams),\n    sortField: parseOldSortFromQueryParams(queryParams)[0],\n    sortDirection: parseOldSortFromQueryParams(queryParams)[1],\n    sortList: parseSortFromQueryParams(queryParams)\n  };\n\n  return Object.keys(state).reduce((acc, key) => {\n    const value = state[key];\n    if (value) acc[key] = value;\n    return acc;\n  }, {});\n}\n\nfunction stateToParams({\n  searchTerm,\n  current,\n  filters,\n  resultsPerPage,\n  sortDirection,\n  sortField,\n  sortList\n}) {\n  const params = {};\n  if (current > 1) params.current = current;\n  if (searchTerm) params.q = searchTerm;\n  if (resultsPerPage) params.size = resultsPerPage;\n  if (filters && filters.length > 0) {\n    params[\"filters\"] = filters;\n  }\nif (sortList && sortList.length > 0) {\n    params[\"sort\"] = sortList;\n  } else if (sortField) {\n    params[\"sort-field\"] = sortField;\n    params[\"sort-direction\"] = sortDirection;\n  }\n  return params;\n}\n\nfunction stateToQueryString(state) {\n  return queryString.stringify(stateToParams(state));\n}\n\n/**\n * The URL Manager is responsible for synchronizing state between\n * SearchDriver and the URL. There are 3 main cases we handle when\n * synchronizing:\n *\n * 1. When the app loads, SearchDriver will need to\n * read the current state from the URL, in order to perform the search\n * expressed by the query string. `getStateFromURL` is used for this case.\n *\n * 2. When the URL changes as a result of `pushState` or `replaceState`,\n * SearchDriver will need to be notified and given the updated state, so that\n * it can re-run the current search. `onURLStateChange` is used for this case.\n *\n * 3. When state changes internally in the SearchDriver, as a result of an\n * Action, it will need to notify the URLManager of the change. `pushStateToURL`\n * is used for this case.\n */\n\nexport default class URLManager {\n  constructor() {\n    this.history = createHistory();\n    this.lastPushSearchString = \"\";\n  }\n\n  /**\n   * Parse the current URL into application state\n   *\n   * @return {Object} - The parsed state object\n   */\n  getStateFromURL() {\n    return paramsToState(queryString.parse(this.history.location.search));\n  }\n\n  /**\n   * Push the current state of the application to the URL\n   *\n   * @param {Object} state - The entire current state from the SearchDriver\n   * @param {boolean} options\n   * @param {boolean} options.replaceUrl - When pushing state to the URL, use history 'replace'\n   * rather than 'push' to avoid adding a new history entry\n   */\n  pushStateToURL(state, { replaceUrl = false } = {}) {\n    const searchString = stateToQueryString(state);\n    this.lastPushSearchString = searchString;\n    const navigationFunction = replaceUrl\n      ? this.history.replace\n      : this.history.push;\n    navigationFunction({\n      search: `?${searchString}`\n    });\n  }\n\n  /**\n   * Add an event handler to be executed whenever state is pushed to the URL\n   *\n   * @callback requestCallback\n   * @param {Object} state - Updated application state parsed from the new URL\n   *\n   * @param {requestCallback} callback\n   */\n  onURLStateChange(callback) {\n    this.unlisten = this.history.listen(location => {\n      // If this URL is updated as a result of a pushState request, we don't\n      // want to notify that the URL changed.\n      if (`?${this.lastPushSearchString}` === location.search) return;\n\n      // Once we've decided to return based on lastPushSearchString, reset\n      // it so that we don't break back / forward button.\n      this.lastPushSearchString = \"\";\n\n      callback(paramsToState(queryString.parse(location.search)));\n    });\n  }\n\n  tearDown() {\n    this.unlisten();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}