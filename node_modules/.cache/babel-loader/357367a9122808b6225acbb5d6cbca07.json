{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport PropTypes from \"prop-types\";\nimport React, { useState, useEffect } from \"react\";\nimport { SearchDriver } from \"@elastic/search-ui\";\nimport SearchContext from \"./SearchContext\";\nimport defaultA11yMessages from \"./A11yNotifications\";\n/**\n * The SearchProvider primarily holds a reference to the SearchDriver and\n * exposes it to the rest of the application in a Context.\n */\n\nvar SearchProvider = function SearchProvider(_ref) {\n  var children = _ref.children,\n      _ref$config = _ref.config,\n      config = _ref$config === void 0 ? {} : _ref$config,\n      driver = _ref.driver;\n\n  var _useState = useState(null),\n      _useState2 = _slicedToArray(_useState, 2),\n      driverInstance = _useState2[0],\n      setDriverInstance = _useState2[1];\n\n  useEffect(function () {\n    // This initialization is done inside of useEffect, because initializing the SearchDriver server side\n    // will error out, since the driver depends on window. Placing the initialization inside of useEffect\n    // assures that it won't attempt to initialize server side.\n    var currentDriver = driver || new SearchDriver(_objectSpread(_objectSpread({}, config), {}, {\n      a11yNotificationMessages: _objectSpread(_objectSpread({}, defaultA11yMessages), config.a11yNotificationMessages)\n    }));\n    setDriverInstance(currentDriver);\n    return function () {\n      currentDriver.tearDown();\n    };\n  }, []); // This effect allows users to dynamically update their searchQuery without re-mounting a SearchProvider,\n  // which would be destructive. An example of why this is useful is dynamically updating facets.\n\n  useEffect(function () {\n    if (driverInstance) {\n      driverInstance.setSearchQuery(config.searchQuery);\n    }\n  }, [config.searchQuery]);\n  useEffect(function () {\n    if (driverInstance) {\n      driverInstance.setAutocompleteQuery(config.autocompleteQuery);\n    }\n  }, [config.autocompleteQuery]); // Since driver is initialized in useEffect above, we are waiting\n  // to render until the driver is available.\n\n  if (!driverInstance) return null; // Passing the entire \"this.state\" to the Context is significant. Because\n  // Context determines when to re-render based on referential identity\n  // something like this could cause unnecessary renders:\n  //\n  // <SearchContext.Provider value={{driver: this.state.driver}}>\n  //\n  // By passing the entire state, we ensure that re-renders only occur when\n  // state is actually updated.\n\n  return /*#__PURE__*/React.createElement(SearchContext.Provider, {\n    value: {\n      driver: driverInstance\n    }\n  }, children);\n};\n\nSearchProvider.propTypes = {\n  children: PropTypes.node.isRequired,\n  // Not providing a shape here because the shape matches the shape of\n  // SearchDriver. SearchDriver can do it's own parameter validation.\n  config: PropTypes.object,\n  driver: PropTypes.object\n};\nexport default SearchProvider;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAOA,SAAP,MAAsB,YAAtB;AACA,OAAOC,KAAP,IAAgBC,QAAhB,EAA0BC,SAA1B,QAA2C,OAA3C;AAEA,SAASC,YAAT,QAA6B,oBAA7B;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AAEA,OAAOC,mBAAP,MAAgC,qBAAhC;AAEA;AACA;AACA;AACA;;AACA,IAAMC,cAAc,GAAG,SAAjBA,cAAiB,OAAuC;AAAA,MAApCC,QAAoC,QAApCA,QAAoC;AAAA,yBAA1BC,MAA0B;AAAA,MAA1BA,MAA0B,4BAAjB,EAAiB;AAAA,MAAbC,MAAa,QAAbA,MAAa;;AAC5D,kBAA4CR,QAAQ,CAAC,IAAD,CAApD;AAAA;AAAA,MAAOS,cAAP;AAAA,MAAuBC,iBAAvB;;AAEAT,WAAS,CAAC,YAAM;AACd;AACA;AACA;AACA,QAAMU,aAAa,GACjBH,MAAM,IACN,IAAIN,YAAJ,iCACKK,MADL;AAEEK,8BAAwB,kCACnBR,mBADmB,GAEnBG,MAAM,CAACK,wBAFY;AAF1B,OAFF;AASAF,qBAAiB,CAACC,aAAD,CAAjBD;AAEA,WAAO,YAAM;AACXC,mBAAa,CAACE,QAAdF;AADF;AAfO,KAkBN,EAlBM,CAATV,CAH4D,CAuB5D;AACA;;AACAA,WAAS,CAAC,YAAM;AACd,QAAIQ,cAAJ,EAAoB;AAClBA,oBAAc,CAACK,cAAfL,CAA8BF,MAAM,CAACQ,WAArCN;AACD;AAHM,KAIN,CAACF,MAAM,CAACQ,WAAR,CAJM,CAATd;AAMAA,WAAS,CAAC,YAAM;AACd,QAAIQ,cAAJ,EAAoB;AAClBA,oBAAc,CAACO,oBAAfP,CAAoCF,MAAM,CAACU,iBAA3CR;AACD;AAHM,KAIN,CAACF,MAAM,CAACU,iBAAR,CAJM,CAAThB,CA/B4D,CAqC5D;AACA;;AACA,MAAI,CAACQ,cAAL,EAAqB,OAAO,IAAP,CAvCuC,CAyC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,sBACEV,oBAACI,aAAD,CAAee,QAAf;AAAwBC,SAAK,EAAE;AAAEX,YAAM,EAAEC;AAAV;AAA/B,KACGH,QADH,CADF;AAjDF;;AAwDAD,cAAc,CAACe,SAAff,GAA2B;AACzBC,UAAQ,EAAER,SAAS,CAACuB,IAAVvB,CAAewB,UADA;AAEzB;AACA;AACAf,QAAM,EAAET,SAAS,CAACyB,MAJO;AAKzBf,QAAM,EAAEV,SAAS,CAACyB;AALO,CAA3BlB;AAQA,eAAeA,cAAf","names":["PropTypes","React","useState","useEffect","SearchDriver","SearchContext","defaultA11yMessages","SearchProvider","children","config","driver","driverInstance","setDriverInstance","currentDriver","a11yNotificationMessages","tearDown","setSearchQuery","searchQuery","setAutocompleteQuery","autocompleteQuery","Provider","value","propTypes","node","isRequired","object"],"sources":["/Users/karina/Main/Study/Web Dev/test-api/node_modules/@elastic/react-search-ui/src/SearchProvider.js"],"sourcesContent":["import PropTypes from \"prop-types\";\nimport React, { useState, useEffect } from \"react\";\n\nimport { SearchDriver } from \"@elastic/search-ui\";\nimport SearchContext from \"./SearchContext\";\n\nimport defaultA11yMessages from \"./A11yNotifications\";\n\n/**\n * The SearchProvider primarily holds a reference to the SearchDriver and\n * exposes it to the rest of the application in a Context.\n */\nconst SearchProvider = ({ children, config = {}, driver }) => {\n  const [driverInstance, setDriverInstance] = useState(null);\n\n  useEffect(() => {\n    // This initialization is done inside of useEffect, because initializing the SearchDriver server side\n    // will error out, since the driver depends on window. Placing the initialization inside of useEffect\n    // assures that it won't attempt to initialize server side.\n    const currentDriver =\n      driver ||\n      new SearchDriver({\n        ...config,\n        a11yNotificationMessages: {\n          ...defaultA11yMessages,\n          ...config.a11yNotificationMessages\n        }\n      });\n    setDriverInstance(currentDriver);\n\n    return () => {\n      currentDriver.tearDown();\n    };\n  }, []);\n\n  // This effect allows users to dynamically update their searchQuery without re-mounting a SearchProvider,\n  // which would be destructive. An example of why this is useful is dynamically updating facets.\n  useEffect(() => {\n    if (driverInstance) {\n      driverInstance.setSearchQuery(config.searchQuery);\n    }\n  }, [config.searchQuery]);\n\n  useEffect(() => {\n    if (driverInstance) {\n      driverInstance.setAutocompleteQuery(config.autocompleteQuery);\n    }\n  }, [config.autocompleteQuery]);\n\n  // Since driver is initialized in useEffect above, we are waiting\n  // to render until the driver is available.\n  if (!driverInstance) return null;\n\n  // Passing the entire \"this.state\" to the Context is significant. Because\n  // Context determines when to re-render based on referential identity\n  // something like this could cause unnecessary renders:\n  //\n  // <SearchContext.Provider value={{driver: this.state.driver}}>\n  //\n  // By passing the entire state, we ensure that re-renders only occur when\n  // state is actually updated.\n  return (\n    <SearchContext.Provider value={{ driver: driverInstance }}>\n      {children}\n    </SearchContext.Provider>\n  );\n};\n\nSearchProvider.propTypes = {\n  children: PropTypes.node.isRequired,\n  // Not providing a shape here because the shape matches the shape of\n  // SearchDriver. SearchDriver can do it's own parameter validation.\n  config: PropTypes.object,\n  driver: PropTypes.object\n};\n\nexport default SearchProvider;\n"]},"metadata":{},"sourceType":"module"}