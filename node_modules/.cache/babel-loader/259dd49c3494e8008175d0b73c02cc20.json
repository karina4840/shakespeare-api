{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"count\", \"value\"],\n    _excluded2 = [\"type\", \"data\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction adaptation1AdaptFacetValue(facetValue) {\n  var additionalFacetValueFieldsForField = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var hasValue = facetValue.hasOwnProperty(\"value\");\n\n  var count = facetValue.count,\n      value = facetValue.value,\n      rest = _objectWithoutProperties(facetValue, _excluded);\n\n  return {\n    count: count,\n    value: hasValue ? value : _objectSpread(_objectSpread({}, rest), additionalFacetValueFieldsForField)\n  };\n}\n\nfunction adaptation2AddLabelToFacet(fieldName, facet) {\n  return _objectSpread({\n    field: fieldName\n  }, facet);\n}\n\nfunction adaptFacets(facets, _ref) {\n  var _ref$additionalFacetV = _ref.additionalFacetValueFields,\n      additionalFacetValueFields = _ref$additionalFacetV === void 0 ? {} : _ref$additionalFacetV;\n  if (!facets || Object.keys(facets).length === 0) return facets;\n  return Object.entries(facets).reduce(function (acc, _ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        fieldName = _ref3[0],\n        facet = _ref3[1];\n\n    var adaptedFacet = facet.map(function (v) {\n      var type = v.type,\n          data = v.data,\n          rest = _objectWithoutProperties(v, _excluded2);\n\n      return adaptation2AddLabelToFacet(fieldName, _objectSpread({\n        type: type,\n        data: data.map(function (f) {\n          return adaptation1AdaptFacetValue(f, additionalFacetValueFields[fieldName]);\n        })\n      }, rest));\n    });\n    return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, fieldName, adaptedFacet));\n  }, {});\n}\n\nfunction limitTo100pages(totalPages) {\n  // We limit this to 100 pages since App Search currently cannot page past 100 pages\n  return Math.min(totalPages, 100);\n}\n\nexport function adaptResponse(response) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var facets = response.info.facets;\n  var requestId = response.info.meta.request_id;\n  var totalPages = response.info.meta.page && typeof response.info.meta.page.total_pages !== \"undefined\" ? limitTo100pages(response.info.meta.page.total_pages) : undefined;\n  var totalResults = response.info.meta.page ? response.info.meta.page.total_results : undefined;\n  return _objectSpread(_objectSpread(_objectSpread({}, facets && {\n    facets: adaptFacets(facets, options)\n  }), {}, {\n    rawResponse: response,\n    requestId: requestId,\n    results: response.rawResults\n  }, totalPages !== undefined && {\n    totalPages: totalPages\n  }), totalResults !== undefined && {\n    totalResults: totalResults\n  });\n}","map":{"version":3,"mappings":"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","names":["adaptation1AdaptFacetValue","facetValue","additionalFacetValueFieldsForField","hasValue","hasOwnProperty","count","value","rest","adaptation2AddLabelToFacet","fieldName","facet","field","adaptFacets","facets","additionalFacetValueFields","Object","keys","length","entries","reduce","acc","adaptedFacet","map","type","v","data","f","limitTo100pages","totalPages","Math","min","adaptResponse","response","options","info","requestId","meta","request_id","page","total_pages","undefined","totalResults","total_results","rawResponse","results","rawResults"],"sources":["/Users/karina/Main/Study/Web Dev/elasticsearch-test-api/node_modules/@elastic/search-ui-app-search-connector/src/responseAdapter.js"],"sourcesContent":["function adaptation1AdaptFacetValue(\n  facetValue,\n  additionalFacetValueFieldsForField = {}\n) {\n  const hasValue = facetValue.hasOwnProperty(\"value\");\n  const { count, value, ...rest } = facetValue;\n  return {\n    count,\n    value: hasValue\n      ? value\n      : {\n          ...rest,\n          ...additionalFacetValueFieldsForField\n        }\n  };\n}\n\nfunction adaptation2AddLabelToFacet(fieldName, facet) {\n  return {\n    field: fieldName,\n    ...facet\n  };\n}\n\nfunction adaptFacets(facets, { additionalFacetValueFields = {} }) {\n  if (!facets || Object.keys(facets).length === 0) return facets;\n\n  return Object.entries(facets).reduce((acc, [fieldName, facet]) => {\n    const adaptedFacet = facet.map(v => {\n      const { type, data, ...rest } = v;\n      return adaptation2AddLabelToFacet(fieldName, {\n        type,\n        data: data.map(f =>\n          adaptation1AdaptFacetValue(f, additionalFacetValueFields[fieldName])\n        ),\n        ...rest\n      });\n    });\n\n    return {\n      ...acc,\n      [fieldName]: adaptedFacet\n    };\n  }, {});\n}\n\nfunction limitTo100pages(totalPages) {\n  // We limit this to 100 pages since App Search currently cannot page past 100 pages\n  return Math.min(totalPages, 100);\n}\n\nexport function adaptResponse(response, options = {}) {\n  const facets = response.info.facets;\n  const requestId = response.info.meta.request_id;\n\n  const totalPages =\n    response.info.meta.page &&\n    typeof response.info.meta.page.total_pages !== \"undefined\"\n      ? limitTo100pages(response.info.meta.page.total_pages)\n      : undefined;\n\n  const totalResults = response.info.meta.page\n    ? response.info.meta.page.total_results\n    : undefined;\n\n  return {\n    ...(facets && { facets: adaptFacets(facets, options) }),\n    rawResponse: response,\n    requestId,\n    results: response.rawResults,\n    ...(totalPages !== undefined && { totalPages }),\n    ...(totalResults !== undefined && { totalResults })\n  };\n}\n"]},"metadata":{},"sourceType":"module"}