{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nvar _excluded = [\"filters\", \"conditionalFacets\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nimport URLManager from \"./URLManager\";\nimport RequestSequencer from \"./RequestSequencer\";\nimport DebounceManager from \"./DebounceManager\";\nimport * as actions from \"./actions\";\nimport Events from \"./Events\";\nimport { mergeFilters } from \"./helpers\";\nimport * as a11y from \"./A11yNotifications\";\n\nfunction filterSearchParameters(_ref) {\n  var current = _ref.current,\n      filters = _ref.filters,\n      resultsPerPage = _ref.resultsPerPage,\n      searchTerm = _ref.searchTerm,\n      sortDirection = _ref.sortDirection,\n      sortField = _ref.sortField,\n      sortList = _ref.sortList;\n  return {\n    current: current,\n    filters: filters,\n    resultsPerPage: resultsPerPage,\n    searchTerm: searchTerm,\n    sortDirection: sortDirection,\n    sortField: sortField,\n    sortList: sortList\n  };\n}\n\nexport var DEFAULT_STATE = {\n  // Search Parameters -- This is state that represents the input state.\n  current: 1,\n  filters: [],\n  resultsPerPage: 20,\n  searchTerm: \"\",\n  sortDirection: \"\",\n  sortField: \"\",\n  sortList: [],\n  // Result State -- This state represents state that is updated automatically\n  // as the result of changing input state.\n  autocompletedResults: [],\n  autocompletedResultsRequestId: \"\",\n  autocompletedSuggestions: {},\n  autocompletedSuggestionsRequestId: \"\",\n  error: \"\",\n  isLoading: false,\n  facets: {},\n  requestId: \"\",\n  results: [],\n  resultSearchTerm: \"\",\n  totalPages: 0,\n  totalResults: 0,\n  pagingStart: 0,\n  pagingEnd: 0,\n  wasSearched: false,\n  rawResponse: {}\n};\n\nfunction removeConditionalFacets() {\n  var facets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var conditionalFacets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var filters = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  return Object.entries(facets).reduce(function (acc, _ref2) {\n    var _ref3 = _slicedToArray(_ref2, 2),\n        facetKey = _ref3[0],\n        facet = _ref3[1];\n\n    if (conditionalFacets[facetKey] && typeof conditionalFacets[facetKey] === \"function\" && !conditionalFacets[facetKey]({\n      filters: filters\n    })) {\n      return acc;\n    }\n\n    acc[facetKey] = facet;\n    return acc;\n  }, {});\n}\n/*\n * The Driver is a framework agnostic search state manager that is capable\n * syncing state to the url.\n */\n\n\nvar SearchDriver = /*#__PURE__*/function () {\n  function SearchDriver(_ref4) {\n    var _this = this;\n\n    var apiConnector = _ref4.apiConnector,\n        _ref4$autocompleteQue = _ref4.autocompleteQuery,\n        autocompleteQuery = _ref4$autocompleteQue === void 0 ? {} : _ref4$autocompleteQue,\n        debug = _ref4.debug,\n        initialState = _ref4.initialState,\n        onSearch = _ref4.onSearch,\n        onAutocomplete = _ref4.onAutocomplete,\n        onResultClick = _ref4.onResultClick,\n        onAutocompleteResultClick = _ref4.onAutocompleteResultClick,\n        _ref4$searchQuery = _ref4.searchQuery,\n        searchQuery = _ref4$searchQuery === void 0 ? {} : _ref4$searchQuery,\n        _ref4$trackUrlState = _ref4.trackUrlState,\n        trackUrlState = _ref4$trackUrlState === void 0 ? true : _ref4$trackUrlState,\n        _ref4$urlPushDebounce = _ref4.urlPushDebounceLength,\n        urlPushDebounceLength = _ref4$urlPushDebounce === void 0 ? 500 : _ref4$urlPushDebounce,\n        _ref4$hasA11yNotifica = _ref4.hasA11yNotifications,\n        hasA11yNotifications = _ref4$hasA11yNotifica === void 0 ? false : _ref4$hasA11yNotifica,\n        _ref4$a11yNotificatio = _ref4.a11yNotificationMessages,\n        a11yNotificationMessages = _ref4$a11yNotificatio === void 0 ? {} : _ref4$a11yNotificatio,\n        _ref4$alwaysSearchOnI = _ref4.alwaysSearchOnInitialLoad,\n        alwaysSearchOnInitialLoad = _ref4$alwaysSearchOnI === void 0 ? false : _ref4$alwaysSearchOnI;\n\n    _classCallCheck(this, SearchDriver);\n\n    _defineProperty(this, \"state\", DEFAULT_STATE);\n\n    _defineProperty(this, \"_updateAutocomplete\", function (searchTerm) {\n      var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          autocompleteResults = _ref5.autocompleteResults,\n          autocompleteSuggestions = _ref5.autocompleteSuggestions;\n\n      var requestId = _this.autocompleteRequestSequencer.next();\n\n      var queryConfig = _objectSpread(_objectSpread({}, autocompleteResults && {\n        results: _this.autocompleteQuery.results || {}\n      }), autocompleteSuggestions && {\n        suggestions: _this.autocompleteQuery.suggestions || {}\n      });\n\n      return _this.events.autocomplete({\n        searchTerm: searchTerm\n      }, queryConfig).then(function (autocompleted) {\n        if (_this.autocompleteRequestSequencer.isOldRequest(requestId)) return;\n\n        _this.autocompleteRequestSequencer.completed(requestId);\n\n        _this._setState(autocompleted);\n      });\n    });\n\n    _defineProperty(this, \"_updateSearchResults\", function (searchParameters) {\n      var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref6$skipPushToUrl = _ref6.skipPushToUrl,\n          skipPushToUrl = _ref6$skipPushToUrl === void 0 ? false : _ref6$skipPushToUrl,\n          _ref6$replaceUrl = _ref6.replaceUrl,\n          replaceUrl = _ref6$replaceUrl === void 0 ? false : _ref6$replaceUrl;\n\n      var _this$state$searchPar = _objectSpread(_objectSpread({}, _this.state), searchParameters),\n          current = _this$state$searchPar.current,\n          filters = _this$state$searchPar.filters,\n          resultsPerPage = _this$state$searchPar.resultsPerPage,\n          searchTerm = _this$state$searchPar.searchTerm,\n          sortDirection = _this$state$searchPar.sortDirection,\n          sortField = _this$state$searchPar.sortField,\n          sortList = _this$state$searchPar.sortList; // State updates should always be applied in the order that they are made. This function, _updateSearchResults,\n      // makes state updates.\n      // In the case where a call to \"_updateSearchResults\" was made and delayed for X amount of time using\n      // `debounceManager.runWithDebounce`, and a subsequent call is made _updateSearchResults before that delay ends, we\n      // want to make sure that outstanding call to \"_updateSearchResults\" is cancelled, as it would apply state updates\n      // out of order.\n\n\n      _this.debounceManager.cancelByName(\"_updateSearchResults\");\n\n      _this._setState({\n        current: current,\n        error: \"\",\n        filters: filters,\n        resultsPerPage: resultsPerPage,\n        searchTerm: searchTerm,\n        sortDirection: sortDirection,\n        sortField: sortField,\n        sortList: sortList\n      });\n\n      _this._makeSearchRequest({\n        skipPushToUrl: skipPushToUrl,\n        replaceUrl: replaceUrl\n      });\n    });\n\n    _defineProperty(this, \"_makeSearchRequest\", DebounceManager.debounce(0, function (_ref7) {\n      var skipPushToUrl = _ref7.skipPushToUrl,\n          replaceUrl = _ref7.replaceUrl;\n      var _this$state = _this.state,\n          current = _this$state.current,\n          filters = _this$state.filters,\n          resultsPerPage = _this$state.resultsPerPage,\n          searchTerm = _this$state.searchTerm,\n          sortDirection = _this$state.sortDirection,\n          sortField = _this$state.sortField,\n          sortList = _this$state.sortList;\n\n      _this._setState({\n        isLoading: true\n      });\n\n      var requestId = _this.searchRequestSequencer.next();\n\n      var _this$searchQuery = _this.searchQuery,\n          searchQueryFilters = _this$searchQuery.filters,\n          conditionalFacets = _this$searchQuery.conditionalFacets,\n          restOfSearchQuery = _objectWithoutProperties(_this$searchQuery, _excluded);\n\n      var queryConfig = _objectSpread(_objectSpread({}, restOfSearchQuery), {}, {\n        facets: removeConditionalFacets(_this.searchQuery.facets, conditionalFacets, filters)\n      });\n\n      var requestState = _objectSpread(_objectSpread({}, filterSearchParameters(_this.state)), {}, {\n        filters: mergeFilters(filters, _this.searchQuery.filters)\n      });\n\n      return _this.events.search(requestState, queryConfig).then(function (resultState) {\n        if (_this.searchRequestSequencer.isOldRequest(requestId)) return;\n\n        _this.searchRequestSequencer.completed(requestId); // Results paging start & end\n\n\n        var totalResults = resultState.totalResults;\n        var start = totalResults === 0 ? 0 : (current - 1) * resultsPerPage + 1;\n        var end = totalResults <= start + resultsPerPage ? totalResults : start + resultsPerPage - 1;\n\n        _this._setState(_objectSpread(_objectSpread({\n          isLoading: false,\n          resultSearchTerm: searchTerm,\n          pagingStart: start,\n          pagingEnd: end\n        }, resultState), {}, {\n          wasSearched: true\n        }));\n\n        if (_this.hasA11yNotifications) {\n          var messageArgs = {\n            start: start,\n            end: end,\n            totalResults: totalResults,\n            searchTerm: searchTerm\n          };\n\n          _this.actions.a11yNotify(\"searchResults\", messageArgs);\n        }\n\n        if (!skipPushToUrl && _this.trackUrlState) {\n          // We debounce here so that we don't get a lot of intermediary\n          // URL state if someone is updating a UI really fast, like typing\n          // in a live search box for instance.\n          _this.debounceManager.runWithDebounce(_this.urlPushDebounceLength, \"pushStateToURL\", _this.URLManager.pushStateToURL.bind(_this.URLManager), {\n            current: current,\n            filters: filters,\n            resultsPerPage: resultsPerPage,\n            searchTerm: searchTerm,\n            sortDirection: sortDirection,\n            sortField: sortField,\n            sortList: sortList\n          }, {\n            replaceUrl: replaceUrl\n          });\n        }\n      }, function (error) {\n        _this._setState({\n          error: \"An unexpected error occurred: \".concat(error.message)\n        });\n      });\n    }));\n\n    this.actions = Object.entries(actions).reduce(function (acc, _ref8) {\n      var _ref9 = _slicedToArray(_ref8, 2),\n          actionName = _ref9[0],\n          action = _ref9[1];\n\n      return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, actionName, action.bind(_this)));\n    }, {});\n    Object.assign(this, this.actions);\n    this.events = new Events({\n      apiConnector: apiConnector,\n      onSearch: onSearch,\n      onAutocomplete: onAutocomplete,\n      onResultClick: onResultClick,\n      onAutocompleteResultClick: onAutocompleteResultClick\n    });\n    this.debug = debug;\n\n    if (this.debug) {\n      console.warn(\"Search UI Debugging is enabled. This should be turned off in production deployments.\");\n      window.searchUI = this;\n    }\n\n    this.autocompleteRequestSequencer = new RequestSequencer();\n    this.searchRequestSequencer = new RequestSequencer();\n    this.debounceManager = new DebounceManager();\n    this.autocompleteQuery = autocompleteQuery;\n    this.searchQuery = searchQuery;\n    this.subscriptions = [];\n    this.trackUrlState = trackUrlState;\n    this.urlPushDebounceLength = urlPushDebounceLength;\n    this.alwaysSearchOnInitialLoad = alwaysSearchOnInitialLoad;\n    var urlState;\n\n    if (trackUrlState) {\n      this.URLManager = new URLManager();\n      urlState = this.URLManager.getStateFromURL();\n      this.URLManager.onURLStateChange(function (urlState) {\n        _this._updateSearchResults(_objectSpread(_objectSpread({}, DEFAULT_STATE), urlState), {\n          skipPushToUrl: true\n        });\n      });\n    } else {\n      urlState = {};\n    } // Manage screen reader accessible notifications\n\n\n    this.hasA11yNotifications = hasA11yNotifications;\n    if (this.hasA11yNotifications) a11y.getLiveRegion();\n    this.a11yNotificationMessages = _objectSpread(_objectSpread({}, a11y.defaultMessages), a11yNotificationMessages); // Remember the state this application is initialized into, so that we can\n    // reset to it later.\n\n    this.startingState = _objectSpread(_objectSpread({}, this.state), initialState); // We filter these here to disallow anything other than valid search\n    // parameters to be passed in initial state, or url state. `results`, etc,\n    // should not be allowed to be passed in, that should be generated based on\n    // the results of the query\n\n    var _searchParameters = filterSearchParameters(_objectSpread(_objectSpread({}, this.startingState), urlState)); // Initialize the state without calling _setState, because we don't\n    // want to trigger an update callback, we're just initializing the state\n    // to the correct default values for the initial UI render\n\n\n    this.state = _objectSpread(_objectSpread({}, this.state), _searchParameters); // We'll trigger an initial search if initial parameters contain\n    // a search term or filters, or if alwaysSearchOnInitialLoad is set.\n    // Otherwise, we'll just save their selections in state as initial values.\n\n    if (_searchParameters.searchTerm || _searchParameters.filters.length > 0 || this.alwaysSearchOnInitialLoad) {\n      this._updateSearchResults(_searchParameters, {\n        replaceUrl: true\n      });\n    }\n  }\n  /**\n   * This method is used to update state and trigger a new autocomplete search.\n   *\n   * @param {string} searchTerm\n   * @param {Object=} Object\n   * @param {boolean|Object} options.autocompleteResults - Should autocomplete results\n   * @param {boolean|Object} options.autocompleteSuggestions - Should autocomplete suggestions\n   */\n\n\n  _createClass(SearchDriver, [{\n    key: \"_setState\",\n    value: function _setState(newState) {\n      var state = _objectSpread(_objectSpread({}, this.state), newState); // eslint-disable-next-line no-console\n\n\n      if (this.debug) console.log(\"Search UI: State Update\", newState, state);\n      this.state = state;\n      this.subscriptions.forEach(function (subscription) {\n        return subscription(state);\n      });\n    }\n    /**\n     * Dynamically update the searchQuery configuration in this driver.\n     * This will issue a new query after being updated.\n     *\n     * @param Object searchQuery\n     */\n\n  }, {\n    key: \"setSearchQuery\",\n    value: function setSearchQuery(searchQuery) {\n      this.searchQuery = searchQuery;\n\n      this._updateSearchResults();\n    }\n    /**\n     * @param Object autocompleteQuery\n     */\n\n  }, {\n    key: \"setAutocompleteQuery\",\n    value: function setAutocompleteQuery(autocompleteQuery) {\n      this.autocompleteQuery = autocompleteQuery;\n    }\n    /**\n     * Any time state is updated in this Driver, the provided callback\n     * will be executed with the updated state.\n     *\n     * @param onStateChange Function\n     */\n\n  }, {\n    key: \"subscribeToStateChanges\",\n    value: function subscribeToStateChanges(onStateChange) {\n      this.subscriptions.push(onStateChange);\n    }\n    /**\n     * @param onStateChange Function\n     */\n\n  }, {\n    key: \"unsubscribeToStateChanges\",\n    value: function unsubscribeToStateChanges(onStateChange) {\n      this.subscriptions = this.subscriptions.filter(function (sub) {\n        return sub !== onStateChange;\n      });\n    }\n    /**\n     * Remove all listeners\n     */\n\n  }, {\n    key: \"tearDown\",\n    value: function tearDown() {\n      this.subscriptions = [];\n      this.URLManager && this.URLManager.tearDown();\n    }\n    /**\n     * Retrieves all available acitons\n     *\n     * @returns Object All actions\n     */\n\n  }, {\n    key: \"getActions\",\n    value: function getActions() {\n      return this.actions;\n    }\n    /**\n     * Retrieve current state. Typically used on app initialization. Subsequent\n     * state updates should come through subscription.\n     *\n     * @returns Object Current state\n     */\n\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      // We return a copy of state here, because we want to ensure the state\n      // inside of this object remains immutable.\n      return _objectSpread({}, this.state);\n    }\n  }]);\n\n  return SearchDriver;\n}();\n\nexport { SearchDriver as default };","map":{"version":3,"mappings":"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","names":["URLManager","RequestSequencer","DebounceManager","actions","Events","mergeFilters","a11y","filterSearchParameters","current","filters","resultsPerPage","searchTerm","sortDirection","sortField","sortList","DEFAULT_STATE","autocompletedResults","autocompletedResultsRequestId","autocompletedSuggestions","autocompletedSuggestionsRequestId","error","isLoading","facets","requestId","results","resultSearchTerm","totalPages","totalResults","pagingStart","pagingEnd","wasSearched","rawResponse","removeConditionalFacets","conditionalFacets","Object","entries","reduce","acc","facetKey","facet","SearchDriver","apiConnector","autocompleteQuery","debug","initialState","onSearch","onAutocomplete","onResultClick","onAutocompleteResultClick","searchQuery","trackUrlState","urlPushDebounceLength","hasA11yNotifications","a11yNotificationMessages","alwaysSearchOnInitialLoad","_classCallCheck","_defineProperty","autocompleteResults","autocompleteSuggestions","_this","autocompleteRequestSequencer","next","queryConfig","suggestions","events","autocomplete","then","isOldRequest","completed","_setState","autocompleted","searchParameters","skipPushToUrl","replaceUrl","state","debounceManager","cancelByName","_makeSearchRequest","debounce","searchRequestSequencer","searchQueryFilters","restOfSearchQuery","requestState","search","resultState","start","end","messageArgs","a11yNotify","runWithDebounce","pushStateToURL","bind","message","actionName","action","assign","console","warn","window","searchUI","subscriptions","urlState","getStateFromURL","onURLStateChange","_updateSearchResults","getLiveRegion","defaultMessages","startingState","length","newState","log","forEach","subscription","onStateChange","push","filter","sub","tearDown"],"sources":["/Users/karina/Main/Study/Web Dev/elasticsearch-test-api/node_modules/@elastic/search-ui/src/SearchDriver.js"],"sourcesContent":["import URLManager from \"./URLManager\";\n\nimport RequestSequencer from \"./RequestSequencer\";\nimport DebounceManager from \"./DebounceManager\";\n\nimport * as actions from \"./actions\";\nimport Events from \"./Events\";\nimport { mergeFilters } from \"./helpers\";\n\nimport * as a11y from \"./A11yNotifications\";\n\nfunction filterSearchParameters({\n  current,\n  filters,\n  resultsPerPage,\n  searchTerm,\n  sortDirection,\n  sortField,\n  sortList\n}) {\n  return {\n    current,\n    filters,\n    resultsPerPage,\n    searchTerm,\n    sortDirection,\n    sortField,\n    sortList\n  };\n}\n\nexport const DEFAULT_STATE = {\n  // Search Parameters -- This is state that represents the input state.\n  current: 1,\n  filters: [],\n  resultsPerPage: 20,\n  searchTerm: \"\",\n  sortDirection: \"\",\n  sortField: \"\",\n  sortList: [],\n  // Result State -- This state represents state that is updated automatically\n  // as the result of changing input state.\n  autocompletedResults: [],\n  autocompletedResultsRequestId: \"\",\n  autocompletedSuggestions: {},\n  autocompletedSuggestionsRequestId: \"\",\n  error: \"\",\n  isLoading: false,\n  facets: {},\n  requestId: \"\",\n  results: [],\n  resultSearchTerm: \"\",\n  totalPages: 0,\n  totalResults: 0,\n  pagingStart: 0,\n  pagingEnd: 0,\n  wasSearched: false,\n  rawResponse: {}\n};\n\nfunction removeConditionalFacets(\n  facets = {},\n  conditionalFacets = {},\n  filters = []\n) {\n  return Object.entries(facets).reduce((acc, [facetKey, facet]) => {\n    if (\n      conditionalFacets[facetKey] &&\n      typeof conditionalFacets[facetKey] === \"function\" &&\n      !conditionalFacets[facetKey]({ filters })\n    ) {\n      return acc;\n    }\n\n    acc[facetKey] = facet;\n    return acc;\n  }, {});\n}\n\n/*\n * The Driver is a framework agnostic search state manager that is capable\n * syncing state to the url.\n */\nexport default class SearchDriver {\n  state = DEFAULT_STATE;\n\n  constructor({\n    apiConnector,\n    autocompleteQuery = {},\n    debug,\n    initialState,\n    onSearch,\n    onAutocomplete,\n    onResultClick,\n    onAutocompleteResultClick,\n    searchQuery = {},\n    trackUrlState = true,\n    urlPushDebounceLength = 500,\n    hasA11yNotifications = false,\n    a11yNotificationMessages = {},\n    alwaysSearchOnInitialLoad = false\n  }) {\n    this.actions = Object.entries(actions).reduce(\n      (acc, [actionName, action]) => {\n        return {\n          ...acc,\n          [actionName]: action.bind(this)\n        };\n      },\n      {}\n    );\n    Object.assign(this, this.actions);\n\n    this.events = new Events({\n      apiConnector,\n      onSearch,\n      onAutocomplete,\n      onResultClick,\n      onAutocompleteResultClick\n    });\n\n    this.debug = debug;\n    if (this.debug) {\n      console.warn(\n        \"Search UI Debugging is enabled. This should be turned off in production deployments.\"\n      );\n      window.searchUI = this;\n    }\n    this.autocompleteRequestSequencer = new RequestSequencer();\n    this.searchRequestSequencer = new RequestSequencer();\n    this.debounceManager = new DebounceManager();\n    this.autocompleteQuery = autocompleteQuery;\n    this.searchQuery = searchQuery;\n    this.subscriptions = [];\n    this.trackUrlState = trackUrlState;\n    this.urlPushDebounceLength = urlPushDebounceLength;\n    this.alwaysSearchOnInitialLoad = alwaysSearchOnInitialLoad;\n\n    let urlState;\n    if (trackUrlState) {\n      this.URLManager = new URLManager();\n      urlState = this.URLManager.getStateFromURL();\n      this.URLManager.onURLStateChange(urlState => {\n        this._updateSearchResults(\n          { ...DEFAULT_STATE, ...urlState },\n          { skipPushToUrl: true }\n        );\n      });\n    } else {\n      urlState = {};\n    }\n\n    // Manage screen reader accessible notifications\n    this.hasA11yNotifications = hasA11yNotifications;\n    if (this.hasA11yNotifications) a11y.getLiveRegion();\n\n    this.a11yNotificationMessages = {\n      ...a11y.defaultMessages,\n      ...a11yNotificationMessages\n    };\n\n    // Remember the state this application is initialized into, so that we can\n    // reset to it later.\n    this.startingState = {\n      ...this.state,\n      ...initialState\n    };\n\n    // We filter these here to disallow anything other than valid search\n    // parameters to be passed in initial state, or url state. `results`, etc,\n    // should not be allowed to be passed in, that should be generated based on\n    // the results of the query\n    const searchParameters = filterSearchParameters({\n      ...this.startingState,\n      ...urlState\n    });\n\n    // Initialize the state without calling _setState, because we don't\n    // want to trigger an update callback, we're just initializing the state\n    // to the correct default values for the initial UI render\n    this.state = {\n      ...this.state,\n      ...searchParameters\n    };\n\n    // We'll trigger an initial search if initial parameters contain\n    // a search term or filters, or if alwaysSearchOnInitialLoad is set.\n    // Otherwise, we'll just save their selections in state as initial values.\n    if (\n      searchParameters.searchTerm ||\n      searchParameters.filters.length > 0 ||\n      this.alwaysSearchOnInitialLoad\n    ) {\n      this._updateSearchResults(searchParameters, { replaceUrl: true });\n    }\n  }\n\n  /**\n   * This method is used to update state and trigger a new autocomplete search.\n   *\n   * @param {string} searchTerm\n   * @param {Object=} Object\n   * @param {boolean|Object} options.autocompleteResults - Should autocomplete results\n   * @param {boolean|Object} options.autocompleteSuggestions - Should autocomplete suggestions\n   */\n  _updateAutocomplete = (\n    searchTerm,\n    { autocompleteResults, autocompleteSuggestions } = {}\n  ) => {\n    const requestId = this.autocompleteRequestSequencer.next();\n\n    const queryConfig = {\n      ...(autocompleteResults && {\n        results: this.autocompleteQuery.results || {}\n      }),\n      ...(autocompleteSuggestions && {\n        suggestions: this.autocompleteQuery.suggestions || {}\n      })\n    };\n\n    return this.events\n      .autocomplete({ searchTerm }, queryConfig)\n      .then(autocompleted => {\n        if (this.autocompleteRequestSequencer.isOldRequest(requestId)) return;\n        this.autocompleteRequestSequencer.completed(requestId);\n\n        this._setState(autocompleted);\n      });\n  };\n\n  /**\n   * This method is used to update state and trigger a new search.\n   *\n   * @typedef {Object} RequestState\n   * @property {number} current\n   * @property {number} resultsPerPage\n   * @property {string} searchTerm\n   * @property {string} sortDirection\n   * @property {string} sortField\n   * @property {Array} sortList\n   *\n   * @param {RequestState} searchParameters - RequestState\n   * @param {Object=} Object\n   * @param {boolean} options.skipPushToUrl - Skip pushing the updated to the URL\n   * @param {boolean} options.replaceUrl - When pushing state to the URL, use history 'replace'\n   * rather than 'push' to avoid adding a new history entry\n   */\n  _updateSearchResults = (\n    searchParameters,\n    { skipPushToUrl = false, replaceUrl = false } = {}\n  ) => {\n    const {\n      current,\n      filters,\n      resultsPerPage,\n      searchTerm,\n      sortDirection,\n      sortField,\n      sortList\n    } = {\n      ...this.state,\n      ...searchParameters\n    };\n\n    // State updates should always be applied in the order that they are made. This function, _updateSearchResults,\n    // makes state updates.\n    // In the case where a call to \"_updateSearchResults\" was made and delayed for X amount of time using\n    // `debounceManager.runWithDebounce`, and a subsequent call is made _updateSearchResults before that delay ends, we\n    // want to make sure that outstanding call to \"_updateSearchResults\" is cancelled, as it would apply state updates\n    // out of order.\n    this.debounceManager.cancelByName(\"_updateSearchResults\");\n\n    this._setState({\n      current,\n      error: \"\",\n      filters,\n      resultsPerPage,\n      searchTerm,\n      sortDirection,\n      sortField,\n      sortList\n    });\n\n    this._makeSearchRequest({\n      skipPushToUrl,\n      replaceUrl\n    });\n  };\n\n  /**\n   * This method is separated out from _updateSearchResults so that it\n   * can be debounced.\n   *\n   * By debouncing our API calls, we can effectively allow action chaining.\n   *\n   * For Ex:\n   *\n   * If a user needs to make multiple filter updates at once, they could\n   * do so by calling an action 3 times in a row:\n   *\n   *   addFilter(\"states\", \"California\");\n   *   addFilter(\"states\", \"Nebraska\");\n   *   addFilter(\"states\", \"Pennsylvania\");\n   *\n   * We don't want to make 3 separate API calls like that in quick succession,\n   * so we debounce the API calls.\n   *\n   * Application state updates are performed in _updateSearchResults, but we\n   * wait to make the actual API calls until all actions have been called.\n   *\n   * @param {Object} options\n   * @param {boolean} options.skipPushToUrl - Skip pushing the updated to the URL\n   * @param {boolean} options.replaceUrl - When pushing state to the URL, use history 'replace'\n   * rather than 'push' to avoid adding a new history entry\n   */\n  _makeSearchRequest = DebounceManager.debounce(\n    0,\n    ({ skipPushToUrl, replaceUrl }) => {\n      const {\n        current,\n        filters,\n        resultsPerPage,\n        searchTerm,\n        sortDirection,\n        sortField,\n        sortList\n      } = this.state;\n\n      this._setState({\n        isLoading: true\n      });\n\n      const requestId = this.searchRequestSequencer.next();\n\n      const {\n        // eslint-disable-next-line no-unused-vars\n        filters: searchQueryFilters,\n        conditionalFacets: conditionalFacets,\n        ...restOfSearchQuery\n      } = this.searchQuery;\n\n      const queryConfig = {\n        ...restOfSearchQuery,\n        facets: removeConditionalFacets(\n          this.searchQuery.facets,\n          conditionalFacets,\n          filters\n        )\n      };\n      const requestState = {\n        ...filterSearchParameters(this.state),\n        filters: mergeFilters(filters, this.searchQuery.filters)\n      };\n\n      return this.events.search(requestState, queryConfig).then(\n        resultState => {\n          if (this.searchRequestSequencer.isOldRequest(requestId)) return;\n          this.searchRequestSequencer.completed(requestId);\n\n          // Results paging start & end\n          const { totalResults } = resultState;\n          const start =\n            totalResults === 0 ? 0 : (current - 1) * resultsPerPage + 1;\n          const end =\n            totalResults <= start + resultsPerPage\n              ? totalResults\n              : start + resultsPerPage - 1;\n\n          this._setState({\n            isLoading: false,\n            resultSearchTerm: searchTerm,\n            pagingStart: start,\n            pagingEnd: end,\n            ...resultState,\n            wasSearched: true\n          });\n\n          if (this.hasA11yNotifications) {\n            const messageArgs = { start, end, totalResults, searchTerm };\n            this.actions.a11yNotify(\"searchResults\", messageArgs);\n          }\n\n          if (!skipPushToUrl && this.trackUrlState) {\n            // We debounce here so that we don't get a lot of intermediary\n            // URL state if someone is updating a UI really fast, like typing\n            // in a live search box for instance.\n            this.debounceManager.runWithDebounce(\n              this.urlPushDebounceLength,\n              \"pushStateToURL\",\n              this.URLManager.pushStateToURL.bind(this.URLManager),\n              {\n                current,\n                filters,\n                resultsPerPage,\n                searchTerm,\n                sortDirection,\n                sortField,\n                sortList\n              },\n              { replaceUrl }\n            );\n          }\n        },\n        error => {\n          this._setState({\n            error: `An unexpected error occurred: ${error.message}`\n          });\n        }\n      );\n    }\n  );\n\n  _setState(newState) {\n    const state = { ...this.state, ...newState };\n    // eslint-disable-next-line no-console\n    if (this.debug) console.log(\"Search UI: State Update\", newState, state);\n    this.state = state;\n    this.subscriptions.forEach(subscription => subscription(state));\n  }\n\n  /**\n   * Dynamically update the searchQuery configuration in this driver.\n   * This will issue a new query after being updated.\n   *\n   * @param Object searchQuery\n   */\n  setSearchQuery(searchQuery) {\n    this.searchQuery = searchQuery;\n    this._updateSearchResults();\n  }\n\n  /**\n   * @param Object autocompleteQuery\n   */\n  setAutocompleteQuery(autocompleteQuery) {\n    this.autocompleteQuery = autocompleteQuery;\n  }\n\n  /**\n   * Any time state is updated in this Driver, the provided callback\n   * will be executed with the updated state.\n   *\n   * @param onStateChange Function\n   */\n  subscribeToStateChanges(onStateChange) {\n    this.subscriptions.push(onStateChange);\n  }\n\n  /**\n   * @param onStateChange Function\n   */\n  unsubscribeToStateChanges(onStateChange) {\n    this.subscriptions = this.subscriptions.filter(\n      sub => sub !== onStateChange\n    );\n  }\n\n  /**\n   * Remove all listeners\n   */\n  tearDown() {\n    this.subscriptions = [];\n    this.URLManager && this.URLManager.tearDown();\n  }\n\n  /**\n   * Retrieves all available acitons\n   *\n   * @returns Object All actions\n   */\n  getActions() {\n    return this.actions;\n  }\n\n  /**\n   * Retrieve current state. Typically used on app initialization. Subsequent\n   * state updates should come through subscription.\n   *\n   * @returns Object Current state\n   */\n  getState() {\n    // We return a copy of state here, because we want to ensure the state\n    // inside of this object remains immutable.\n    return { ...this.state };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}