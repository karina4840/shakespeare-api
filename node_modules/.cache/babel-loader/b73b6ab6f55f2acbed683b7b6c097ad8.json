{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n/**\n * minimal debounce function\n *\n * mostly for not spamming the server with requests when\n * searching with type ahead\n */\n\nfunction debounce(func, wait) {\n  var timeout;\n\n  var debouncedFn = function debouncedFn() {\n    var args = arguments;\n\n    var later = function later() {\n      func.apply(null, args);\n    };\n\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n\n  debouncedFn.cancel = function () {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n\n  return debouncedFn;\n}\n\nvar DebounceManager = /*#__PURE__*/function () {\n  function DebounceManager() {\n    _classCallCheck(this, DebounceManager);\n\n    _defineProperty(this, \"debounceCache\", {});\n  }\n\n  _createClass(DebounceManager, [{\n    key: \"runWithDebounce\",\n    value:\n    /**\n     * Dynamically debounce and cache a debounced version of a function at the time of calling that function. This avoids\n     * managing debounced version of functions locally.\n     *\n     * In other words, debounce usually works by debouncing based on\n     * referential identity of a function. This works by comparing provided function names.\n     *\n     * This also has the ability to short-circuit a debounce all-together, if no wait\n     * time is provided.\n     *\n     * Assumption:\n     * Functions are debounced on a combination of unique function name and wait times. So debouncing won't work on\n     * subsequent calls with different wait times or different functions. That also means that the debounce manager\n     * can be used for different functions in parallel, and keep the two functions debounced separately.\n     *\n     * @param {number} wait Milliseconds to debounce. Executes immediately if falsey.\n     * @param {function} fn Function to debounce\n     * @param {function} functionName Name of function to debounce, used to create a unique key\n     * @param {...any} parameters Parameters to pass to function\n     */\n    function runWithDebounce(wait, functionName, fn) {\n      for (var _len = arguments.length, parameters = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        parameters[_key - 3] = arguments[_key];\n      }\n\n      if (!wait) {\n        return fn.apply(void 0, parameters);\n      }\n\n      var key = \"\".concat(functionName, \"|\").concat(wait.toString());\n      var debounced = this.debounceCache[key];\n\n      if (!debounced) {\n        this.debounceCache[key] = debounce(fn, wait);\n        debounced = this.debounceCache[key];\n      }\n\n      debounced.apply(void 0, parameters);\n    }\n    /**\n     * Cancels existing debounced function calls.\n     *\n     * This will cancel any debounced function call, regardless of the debounce length that was provided.\n     *\n     * For example, making the following series of calls will create multiple debounced functions, because\n     * they are cached by a combination of unique name and debounce length.\n     *\n     * runWithDebounce(1000, \"_updateSearchResults\", this._updateSearchResults)\n     * runWithDebounce(500, \"_updateSearchResults\", this._updateSearchResults)\n     * runWithDebounce(1000, \"_updateSearchResults\", this._updateSearchResults)\n     *\n     * Calling the following will cancel all of those, if they have not yet executed:\n     *\n     * cancelByName(\"_updateSearchResults\")\n     *\n     * @param {string} functionName The name of the function that was debounced. This needs to match exactly what was provided\n     * when runWithDebounce was called originally.\n     */\n\n  }, {\n    key: \"cancelByName\",\n    value: function cancelByName(functionName) {\n      Object.entries(this.debounceCache).filter(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n            cachedKey = _ref2[0];\n\n        return cachedKey.startsWith(\"\".concat(functionName, \"|\"));\n      }) // eslint-disable-next-line no-unused-vars\n      .forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            _ = _ref4[0],\n            cachedValue = _ref4[1];\n\n        return cachedValue.cancel();\n      });\n    }\n  }]);\n\n  return DebounceManager;\n}();\n/**\n * Perform a standard debounce\n *\n * @param {number} wait Milliseconds to debounce. Executes immediately if falsey.\n * @param {function} fn Function to debounce\n */\n\n\nDebounceManager.debounce = function (wait, fn) {\n  return debounce(fn, wait);\n};\n\nexport default DebounceManager;","map":{"version":3,"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,QAAT,CAAkBC,IAAlB,EAAwBC,IAAxB,EAA8B;AAC5B,MAAIC,OAAJ;;AACA,MAAMC,WAAW,GAAG,SAAdA,WAAc,GAAW;AAC7B,QAAMC,IAAI,GAAGC,SAAb;;AACA,QAAMC,KAAK,GAAG,SAARA,KAAQ,GAAM;AAClBN,UAAI,CAACO,KAALP,CAAW,IAAXA,EAAiBI,IAAjBJ;AADF;;AAGAQ,gBAAY,CAACN,OAAD,CAAZM;AACAN,WAAO,GAAGO,UAAU,CAACH,KAAD,EAAQL,IAAR,CAApBC;AANF;;AAQAC,aAAW,CAACO,MAAZP,GAAqB,YAAM;AACzB,QAAID,OAAJ,EAAa;AACXM,kBAAY,CAACN,OAAD,CAAZM;AACAN,aAAO,GAAG,IAAVA;AACD;AAJH;;AAMA,SAAOC,WAAP;AACD;;IAEKQ,e;;;;2CACY;;;;;;AAEhB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,6BAAgBV,IAAhB,EAAsBW,YAAtB,EAAoCC,EAApC,EAAuD;AAAA,wCAAZC,UAAY;AAAZA,kBAAY,UAAZA,GAAYT,eAAZS;AAAY;;AACrD,UAAI,CAACb,IAAL,EAAW;AACT,eAAOY,EAAE,MAAFA,SAAMC,UAAND,CAAP;AACD;;AAED,UAAME,GAAG,aAAMH,YAAN,cAAsBX,IAAI,CAACe,QAALf,EAAtB,CAAT;AACA,UAAIgB,SAAS,GAAG,KAAKC,aAAL,CAAmBH,GAAnB,CAAhB;;AACA,UAAI,CAACE,SAAL,EAAgB;AACd,aAAKC,aAAL,CAAmBH,GAAnB,IAA0BhB,QAAQ,CAACc,EAAD,EAAKZ,IAAL,CAAlC;AACAgB,iBAAS,GAAG,KAAKC,aAAL,CAAmBH,GAAnB,CAAZE;AACD;;AACDA,eAAS,MAATA,SAAaH,UAAbG;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACE,sBAAaL,YAAb,EAA2B;AACzBO,YAAM,CAACC,OAAPD,CAAe,KAAKD,aAApBC,EACGE,MADHF,CACU;AAAA;AAAA,YAAEG,SAAF;;AAAA,eAAiBA,SAAS,CAACC,UAAVD,WAAwBV,YAAxB,OAAjB;AADV,SAEE;AAFFO,OAGGK,OAHHL,CAGW;AAAA;AAAA,YAAEM,CAAF;AAAA,YAAKC,WAAL;;AAAA,eAAsBA,WAAW,CAAChB,MAAZgB,EAAtB;AAHX;AAID;;;;;AAEH;AACA;AACA;AACA;AACA;AACA;;;AACAf,eAAe,CAACZ,QAAhBY,GAA2B,UAACV,IAAD,EAAOY,EAAP,EAAc;AACvC,SAAOd,QAAQ,CAACc,EAAD,EAAKZ,IAAL,CAAf;AADF;;AAIA,eAAeU,eAAf","names":["debounce","func","wait","timeout","debouncedFn","args","arguments","later","apply","clearTimeout","setTimeout","cancel","DebounceManager","functionName","fn","parameters","key","toString","debounced","debounceCache","Object","entries","filter","cachedKey","startsWith","forEach","_","cachedValue"],"sources":["/Users/karina/Main/Study/Web Dev/elasticsearch-api-test/node_modules/@elastic/search-ui/src/DebounceManager.js"],"sourcesContent":["/**\n * minimal debounce function\n *\n * mostly for not spamming the server with requests when\n * searching with type ahead\n */\nfunction debounce(func, wait) {\n  let timeout;\n  const debouncedFn = function() {\n    const args = arguments;\n    const later = () => {\n      func.apply(null, args);\n    };\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n  };\n  debouncedFn.cancel = () => {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  };\n  return debouncedFn;\n}\n\nclass DebounceManager {\n  debounceCache = {};\n\n  /**\n   * Dynamically debounce and cache a debounced version of a function at the time of calling that function. This avoids\n   * managing debounced version of functions locally.\n   *\n   * In other words, debounce usually works by debouncing based on\n   * referential identity of a function. This works by comparing provided function names.\n   *\n   * This also has the ability to short-circuit a debounce all-together, if no wait\n   * time is provided.\n   *\n   * Assumption:\n   * Functions are debounced on a combination of unique function name and wait times. So debouncing won't work on\n   * subsequent calls with different wait times or different functions. That also means that the debounce manager\n   * can be used for different functions in parallel, and keep the two functions debounced separately.\n   *\n   * @param {number} wait Milliseconds to debounce. Executes immediately if falsey.\n   * @param {function} fn Function to debounce\n   * @param {function} functionName Name of function to debounce, used to create a unique key\n   * @param {...any} parameters Parameters to pass to function\n   */\n  runWithDebounce(wait, functionName, fn, ...parameters) {\n    if (!wait) {\n      return fn(...parameters);\n    }\n\n    const key = `${functionName}|${wait.toString()}`;\n    let debounced = this.debounceCache[key];\n    if (!debounced) {\n      this.debounceCache[key] = debounce(fn, wait);\n      debounced = this.debounceCache[key];\n    }\n    debounced(...parameters);\n  }\n\n  /**\n   * Cancels existing debounced function calls.\n   *\n   * This will cancel any debounced function call, regardless of the debounce length that was provided.\n   *\n   * For example, making the following series of calls will create multiple debounced functions, because\n   * they are cached by a combination of unique name and debounce length.\n   *\n   * runWithDebounce(1000, \"_updateSearchResults\", this._updateSearchResults)\n   * runWithDebounce(500, \"_updateSearchResults\", this._updateSearchResults)\n   * runWithDebounce(1000, \"_updateSearchResults\", this._updateSearchResults)\n   *\n   * Calling the following will cancel all of those, if they have not yet executed:\n   *\n   * cancelByName(\"_updateSearchResults\")\n   *\n   * @param {string} functionName The name of the function that was debounced. This needs to match exactly what was provided\n   * when runWithDebounce was called originally.\n   */\n  cancelByName(functionName) {\n    Object.entries(this.debounceCache)\n      .filter(([cachedKey]) => cachedKey.startsWith(`${functionName}|`))\n      // eslint-disable-next-line no-unused-vars\n      .forEach(([_, cachedValue]) => cachedValue.cancel());\n  }\n}\n/**\n * Perform a standard debounce\n *\n * @param {number} wait Milliseconds to debounce. Executes immediately if falsey.\n * @param {function} fn Function to debounce\n */\nDebounceManager.debounce = (wait, fn) => {\n  return debounce(fn, wait);\n};\n\nexport default DebounceManager;\n"]},"metadata":{},"sourceType":"module"}